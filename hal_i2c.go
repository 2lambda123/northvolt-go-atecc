package atecc

import (
	"bytes"
	"context"
	"errors"
	"time"

	"periph.io/x/conn/v3"
	"periph.io/x/conn/v3/i2c"
)

// NewI2CDev returns an object that communicates over IÂ²C to ATECC608A.
//
// NOTE: the address passed in here is the actual target address. In upstream
// MicrochipTech cryptoauthlib, the address used is shifted.
func NewI2CDev(ctx context.Context, cfg IfaceConfig) (*Dev, error) {
	// TODO: pass address and bus in as arguments? makes it more explicit.
	//       or expose NewHALI2C() -- and allow New() to take hal.
	d, err := New(ctx, newHALI2C(cfg.I2C.Bus, cfg.I2C.Address, cfg), cfg)
	return d, err
}

// i2c words
var (
	// wordWake is used to wake the i2c bus up by sending it to address 0.
	wordWake    uint8 = 0x01
	wordIdle    uint8 = 0x02
	wordCommand uint8 = 0x03
)

type halI2C struct {
	bus  i2c.Bus
	phy  *i2c.Dev
	conn conn.Conn
	cfg  IfaceConfig
}

func newHALI2C(bus i2c.Bus, addr uint16, cfg IfaceConfig) *halI2C {
	return &halI2C{
		bus:  bus,
		phy:  &i2c.Dev{Bus: bus, Addr: 0},
		conn: &i2c.Dev{Bus: bus, Addr: addr},
		cfg:  cfg,
	}
}

func (h *halI2C) Write(data []byte) (int, error) {
	cmd := append([]byte{wordCommand}, data...)
	err := h.conn.Tx(cmd, nil)
	return len(data), err
}

func (h *halI2C) Read(buf []byte) (int, error) {
	// determine many bytes to be read
	if err := h.conn.Tx([]byte{0x0}, buf[0:1]); err != nil {
		return 0, err
	}
	size := int(buf[0])
	if size > cap(buf) {
		return 1, errRecvBuffer
	} else if size < 4 {
		return 1, errors.New("atecc: invalid packet size")
	}

	// read size (excluding 1 byte already read)
	if err := h.conn.Tx(nil, buf[1:size:size]); err != nil {
		return 1, err
	}

	return size, nil
}

func (h *halI2C) Idle() error {
	return h.conn.Tx([]byte{wordIdle}, nil)
}

func (h *halI2C) Wake() error {
	// TODO: move back to 100k baud if needed
	// defer () {
	// TODO: move back to whatever baud we had before
	// }()

	var err error
	for i := 0; i < h.cfg.RxRetries; i++ {
		// Send wake pulse 0x01 on the 0x00 address. As described by Adafruit:
		//
		// > This is a hack to generate the ATECC Wake condition, which is SDA held
		// > low for t > 60us (twlo). For an I2C clock freq of 100kHz, 8 clock
		// > cycles will be 80us. This signal is generated by trying to address
		// > something at 0x00. It will fail, but the pattern should wake up the
		// > ATECC.
		_ = h.phy.Tx([]byte{wordWake}, nil)

		// Allow tWHI + tWLO to take its time.
		time.Sleep(h.cfg.WakeDelay)

		// Return if we receive a response.
		var r [4]byte
		if err = h.conn.Tx(nil, r[:]); err == nil {
			if err = checkWakeUp(r[:]); err == nil {
				return nil
			}
		}
	}

	return err
}

// checkWakeUp validates the response from the wake up call.
func checkWakeUp(data []byte) error {
	var (
		expected = []byte{0x04, 0x11, 0x33, 0x43}
		selftest = []byte{0x04, 0x07, 0xC4, 0x40}
	)
	if bytes.Equal(data, expected) {
		return nil
	} else if bytes.Equal(data, selftest) {
		return errors.New("atecc: self-test error")
	} else {
		return errors.New("atecc: wake failed")
	}
}
